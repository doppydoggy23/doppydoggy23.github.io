//ToDo: check why did_touch_wall_left/right only work with player_map_y+1
//ToDo: if we remove the (+enemy_char_width) from visibility check of enemies and activate no draw of row 0, it's smoother
//ToDo: change the hardwritten "goto mode play_level1()"" and "goto mode play_level2()"" for variables pointing to the current level

mapfab(raw, "t7.mapfab", "chr", "palette", "metatiles", "level")


ct UU x_window_min=50 // the player character will move within these x coords without causing x scroll
ct UU x_window_max=206
ct UU player_x_move_inc=1 // the char will move these many pixels in x at a time
ct UU player_char_width=16
ct UU player_char_height=16

ct U pass_through_mt=12 // transparent metatiles
ct U num_jump_values=30 // size of the screen pixels the player will move up in a frame (jump_values)
ct U falling_rate_px=2 // pixels the player will fall in a single frame

// Snake enemies
struct SnakeEnemy
    UU map_x
    UU map_y
    UU initial_x
    UU final_x
    S x_speed
    U status // 0-alive 1-killed and falling 2-killed and off the screen
//
ct U max_num_snake_enemies=10
ct UU enemy_char_width=16
ct UU enemy_char_height=16

// plarforms
struct Platform
    UU map_x
    UU map_y
    UU initial_x
    UU final_x
    S x_speed
//
ct U max_platforms=10
ct UU platform_width=16


vars /game_vars
    CCC/levels lvl1_mt_map // level 1 metatile map and its tiles correspondence
    CC/metatiles mt_nw
    CC/metatiles mt_ne
    CC/metatiles mt_sw
    CC/metatiles mt_se
    CC/metatiles mt_attr

    UU my_x_scroll=0 // this points to the current h. scroll value
    UU maximum_x // this will point to the map maximum x scroll value
    UU scr_bg_update_base_addr // addrs where to copy data during NMI
    UU scr_attr_bg_update_base_addr
    Bool scr_bg_update_needed=false
    U[30] scroll_tiles // The data we'll upload to the PPU during NMI.
    U[8] scroll_attrs

    UU player_window_x//player_initial_x // player character coords locally in screen (not inside map)
    UU player_map_x//player_initial_x // player char coordinates globally (in the map)
    UU player_y//player_initial_y // only one global y coordinate for the player

    //
    Bool is_player_jumping=false
    U count_frames_jumping=0
    Bool is_player_on_ground=false
    U[num_jump_values] jump_values = U[num_jump_values](4, 4, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0) 
    U[16] chr_sprt_table = U[16](230, 231, 246, 247, 228, 229, 244, 245,   231, 230, 247, 246, 229, 228, 245, 244) // chr table of player sprites 1 & 2
    // otro U[16] chr_sprt_table = U[16](37, 38, 53, 54, 39, 40, 55, 56,   231, 230, 247, 246, 229, 228, 245, 244) // chr table of player sprites 1 & 2
    U[20] e_chr_sprt_table = U[20](234, 235, 250, 251, 232, 233, 248, 249,     235, 234, 251, 250, 233, 232, 249, 248,      251, 250, 235, 234) // chr table of enemies sprites 1 & 2
    U which_player_sprite_show = 0
    Bool is_player_looking_left = false
    Bool is_player_on_platform=false
    
    //enemies
    SnakeEnemy[max_num_snake_enemies] snake_enemies
    U level_num_snake_enemies
    //platforms
    Platform[max_platforms] f_platforms
    U level_num_platforms

/*
Writes the initial 32x30 screen. Take note the mapfab is (16*4)H x 16V. 
It has a 16th row of tiles that will never be seen to make multiplications
by its height a power of two (faster)
*/
fn load_level(CCC/levels my_lvl_pointer)
    U chr_bank = read U(my_lvl_pointer)
    CCC/palettes pal=read CCC/palettes(my_lvl_pointer)
    CC/metatiles mymetatiles=read CC/metatiles(my_lvl_pointer)
    UU size = UU(read U(my_lvl_pointer)) // width in metatiles of screen
    //after all these reads, now my_lvl_pointer points to the metatiles matrix

    maximum_x=size<<4 // sets the maximum x value to scroll to
    maximum_x-=256 //

    // set palette
    load_palette(pal)
    ppu_upload_palette()
       
    UU mt_size = UU(read U(mymetatiles)) // number of metatiles
    if mt_size == 0
        mt_size = 256

    lvl1_mt_map=my_lvl_pointer // the map is set in columns. it's in level.macrofab
    
    mt_nw=mymetatiles
    mt_ne=mt_nw
    mt_ne+=mt_size
    mt_sw=mt_ne
    mt_sw+=mt_size
    mt_se=mt_sw
    mt_se+=mt_size
    mt_attr=mt_se
    mt_attr+=mt_size
    // now every pointer points where it should

    ppu_reset_addr($2000) // first screen // https://www.nesdev.org/wiki/Mirroring

    {PPUSTATUS}() // Reset the address latch before 'ppu_set_addr', just to be safe.
    {PPUCTRL}(PPUCTRL_VRAM_32_DOWN) // Used to write columns of data.

    // upload first namespace data
    UU i=0
    UU ii=0

    for UU x=0; x<16; x+=1
        ppu_reset_addr($2000+ii)
        for UU y=0; y<16; y+=1
            U my_metatile=my_lvl_pointer{i}
            U nw_tile=mt_nw{my_metatile}
            U sw_tile=mt_sw{my_metatile}
            {PPUDATA}(nw_tile)
            {PPUDATA}(sw_tile)
            i+=1
        i-=16
        ii+=1
        ppu_reset_addr($2000+ii)
        for UU y=0; y<16; y+=1
            U my_metatile=my_lvl_pointer{i}
            U ne_tile=mt_ne{my_metatile}
            U se_tile=mt_se{my_metatile}
            {PPUDATA}(ne_tile)
            {PPUDATA}(se_tile)
            i+=1
        ii+=1

    //upload first attributes data, we need to OR it together
    //for every 2x2 metatiles block (https://www.nesdev.org/wiki/PPU_attribute_tables)
    i=0
    ii=0
    for UU a=0; a<8; a+=1
        for UU attri=0; attri<32; attri+=8
            ppu_reset_addr($2000+960+a+attri)
            U my_metatile=my_lvl_pointer{i} //tl
            U my_attr=mt_attr{my_metatile}
            //
            my_metatile=my_lvl_pointer{i+16} // tr
            my_attr|=(mt_attr{my_metatile}<<2)
            //
            my_metatile=my_lvl_pointer{i+1} //bl
            my_attr|=(mt_attr{my_metatile}<<4)
            //
            my_metatile=my_lvl_pointer{i+17} //br
            my_attr|=(mt_attr{my_metatile}<<6)
            //
            {PPUDATA}(my_attr)
            //
            my_metatile=my_lvl_pointer{i+8} //tl
            my_attr=mt_attr{my_metatile}
            //
            my_metatile=my_lvl_pointer{i+16+8} // tr
            my_attr|=(mt_attr{my_metatile}<<2)
            //
            my_metatile=my_lvl_pointer{i+1+8} //bl
            my_attr|=(mt_attr{my_metatile}<<4)
            //
            my_metatile=my_lvl_pointer{i+17+8} //br
            my_attr|=(mt_attr{my_metatile}<<6)
            //
            {PPUDATA}(my_attr)
            i+=2
        ii+=32
        i=ii
    // fn end

fn set_level1_vars()
    // create enemies
    // look at the metatile coords in MapFab and then multiply by 16
    snake_enemies[0].initial_x=368 // (23,10)-(27,10)
    snake_enemies[0].map_x=snake_enemies[0].initial_x
    snake_enemies[0].final_x=432// (23,10)-(27,10)
    snake_enemies[0].map_y=160
    snake_enemies[0].x_speed=1
    snake_enemies[0].status=0
    //
    snake_enemies[1].initial_x=160 // (10,13)-(13,13)
    snake_enemies[1].map_x=snake_enemies[1].initial_x
    snake_enemies[1].final_x=208 // (10,13)-(13,13)
    snake_enemies[1].map_y=208
    snake_enemies[1].x_speed=1
    snake_enemies[1].status=0
    //
    snake_enemies[2].initial_x=400 // (25,8)-(28,8)
    snake_enemies[2].map_x=snake_enemies[2].initial_x
    snake_enemies[2].final_x=448 
    snake_enemies[2].map_y=128
    snake_enemies[2].x_speed=1
    snake_enemies[2].status=0
    //
    snake_enemies[3].initial_x=432 // (27,6)-(30,6)
    snake_enemies[3].map_x=snake_enemies[3].initial_x
    snake_enemies[3].final_x=480 
    snake_enemies[3].map_y=96
    snake_enemies[3].x_speed=1
    snake_enemies[3].status=0
    //
    snake_enemies[4].initial_x=576 // (36,12)-(41,12)
    snake_enemies[4].map_x=snake_enemies[4].initial_x
    snake_enemies[4].final_x=656 
    snake_enemies[4].map_y=192
    snake_enemies[4].x_speed=1
    snake_enemies[4].status=0
    //
    snake_enemies[5].initial_x=704 // (44,10)-(48,10)
    snake_enemies[5].map_x=snake_enemies[5].initial_x
    snake_enemies[5].final_x=768 
    snake_enemies[5].map_y=160
    snake_enemies[5].x_speed=1
    snake_enemies[5].status=0
    //
    snake_enemies[6].initial_x=768 // (48,13)-(52,13)
    snake_enemies[6].map_x=snake_enemies[6].initial_x
    snake_enemies[6].final_x=832 
    snake_enemies[6].map_y=208
    snake_enemies[6].x_speed=1
    snake_enemies[6].status=0
    //
    snake_enemies[7].initial_x=912 // (57,13)-(61,13)
    snake_enemies[7].map_x=snake_enemies[7].initial_x
    snake_enemies[7].final_x=976 
    snake_enemies[7].map_y=208
    snake_enemies[7].x_speed=1
    snake_enemies[7].status=0
    // rest of global of vars

    my_x_scroll=0 // this points to the current h. scroll value
    scr_bg_update_needed=false
    player_window_x=58 // player character coords locally in screen (not inside map)
    player_map_x=player_window_x // player char coordinates globally (in the map)
    player_y=120 // only one global y coordinate for the player
    is_player_jumping=false
    count_frames_jumping=0
    is_player_on_ground=false
    which_player_sprite_show = 0
    is_player_looking_left = false
    level_num_snake_enemies=8
    level_num_platforms=0
    is_player_on_platform=false
    //


fn set_level2_vars()
    // rest of global of vars
    my_x_scroll=0 // this points to the current h. scroll value
    scr_bg_update_needed=false
    player_window_x=20 // player character coords locally in screen (not inside map)
    player_map_x=player_window_x // player char coordinates globally (in the map)
    player_y=120 // only one global y coordinate for the player
    is_player_jumping=false
    count_frames_jumping=0
    is_player_on_ground=false
    which_player_sprite_show = 0
    is_player_looking_left = false
    level_num_snake_enemies=0
    level_num_platforms=1
    is_player_on_platform=false
    //platforms
    f_platforms[0].initial_x=32
    f_platforms[0].map_x=f_platforms[0].initial_x // 2,14-12,14
    f_platforms[0].map_y=224
    f_platforms[0].final_x=192
    f_platforms[0].x_speed=1


// jump here to play level 1
mode play_level1()
: nmi main_nmi 
    {PPUCTRL}(0)  // Reset PPU control register for new level
    {PPUMASK}(0) // Reset PPU mask register for new level
    hide_oam(0)// Clear OAM to start fresh
    load_level(@lev_level1) // the name lev_level1 is defined in the levels.macrofab
    set_level1_vars()
    {PPUCTRL}(PPUCTRL_NMI_ON)// Re-enable NMI

    while true
        update_pads()
        move_player() 
        move_enemies() 
        update_sprites()
        nmi // Wait for the next NMI

// jump here to play level 2
mode play_level2()
: nmi main_nmi 
    {PPUCTRL}(0)  // Reset PPU control register for new level
    {PPUMASK}(0) // Reset PPU mask register for new level
    hide_oam(0)// Clear OAM to start fresh
    load_level(@lev_level2) // the name lev_level1 is defined in the levels.macrofab
    set_level2_vars()
    {PPUCTRL}(PPUCTRL_NMI_ON)// Re-enable NMI

    while true
        update_pads()
        move_player() 
        move_enemies() 
        move_platforms()
        update_sprites()
        nmi // Wait for the next NMI


nmi main_nmi()
    // Update OAM and poll the pads:
    ppu_upload_oam_poll_pads(0)
    // Turn on rendering:
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)
    // Reset the scroll https://www.nesdev.org/wiki/PPU_scrolling
    // and https://www.nesdev.org/wiki/Mirroring
    if scr_bg_update_needed
        nmi_update_screen_bg()
    //
    ppu_reset_scroll_16(my_x_scroll, 0)
    
mode main()
    goto mode play_level2()  // Initialize game by entering the play level mode
    : preserves

// update the sprites
fn update_sprites()
    // Our stack index into OAM:
    U i = 0
    // Push sprites
    // calculate player character on screen
    U pcx=player_window_x.a
    U pcy=player_y.a
    U pattr=0
    if (is_player_looking_left)
        pattr|=%01000000
    // draw player character sprites
    set_oam_x(i, pcx)     // x-position
    set_oam_y(i, pcy) // y-position
    set_oam_p(i, chr_sprt_table[(which_player_sprite_show<<2)])    // tile
    set_oam_a(i, pattr|1)      // options
    i += 4
    set_oam_x(i, pcx+8)     // x-position
    set_oam_y(i, pcy) // y-position
    set_oam_p(i, chr_sprt_table[(which_player_sprite_show<<2)+1])    // tile
    set_oam_a(i, pattr|1)      // options
    i += 4
    set_oam_x(i, pcx)     // x-position
    set_oam_y(i, pcy+8) // y-position
    set_oam_p(i, chr_sprt_table[(which_player_sprite_show<<2)+2])    // tile
    set_oam_a(i, pattr)      // options
    i += 4
    set_oam_x(i, pcx+8)     // x-position
    set_oam_y(i, pcy+8) // y-position
    set_oam_p(i, chr_sprt_table[(which_player_sprite_show<<2)+3])    // tile
    set_oam_a(i, pattr)      // options
    i += 4
    
    // draw enemies
    for U ei=0; ei<level_num_snake_enemies; ei+=1
        if ( (snake_enemies[ei].status < 2) && (snake_enemies[ei].map_x > my_x_scroll) && ((snake_enemies[ei].map_x+enemy_char_width) < (my_x_scroll+256)) )
            UU tex=snake_enemies[ei].map_x-my_x_scroll
            U ex=tex.a
            U ey=snake_enemies[ei].map_y.a
            U attrs=2 // https://www.nesdev.org/wiki/PPU_OAM
            U which_sprite=(snake_enemies[ei].map_x.a>>4)&1
            //
            if (snake_enemies[ei].x_speed < 0) // going left
                attrs|=%01000000 // flip h
                which_sprite+=2
            //
            if (snake_enemies[ei].status == 1) //falling enemy
                attrs|=%11000000 // flip h&v
                which_sprite=4 // flip h&v
            //
            set_oam_x(i, ex)     // x-position
            set_oam_y(i, ey) // y-position
            set_oam_p(i, e_chr_sprt_table[(which_sprite<<2)])    // tile
            set_oam_a(i, attrs)      // options
            i += 4
            set_oam_x(i, ex+8)     // x-position
            set_oam_y(i, ey) // y-position
            set_oam_p(i, e_chr_sprt_table[(which_sprite<<2)+1])    // tile
            set_oam_a(i, attrs)      // options
            i += 4
            set_oam_x(i, ex)     // x-position
            set_oam_y(i, ey+8) // y-position
            set_oam_p(i, e_chr_sprt_table[(which_sprite<<2)+2])    // tile
            set_oam_a(i, attrs)      // options
            i += 4
            set_oam_x(i, ex+8)     // x-position
            set_oam_y(i, ey+8) // y-position
            set_oam_p(i, e_chr_sprt_table[(which_sprite<<2)+3])    // tile
            set_oam_a(i, attrs)      // options
            i += 4
    //
    //draw platforms
    for U pi=0; pi<level_num_platforms; pi+=1
        if ( (f_platforms[pi].map_x > my_x_scroll) && ((f_platforms[pi].map_x+platform_width) < (my_x_scroll+256)) )
            UU tex=f_platforms[pi].map_x-my_x_scroll
            U px=tex.a
            U py=f_platforms[pi].map_y.a
            U pattrs=0 // https://www.nesdev.org/wiki/PPU_OAM
            U pwhich_sprite=41
            //
            set_oam_x(i, px)     // x-position
            set_oam_y(i, py) // y-position
            set_oam_p(i, pwhich_sprite)    // tile
            set_oam_a(i, pattrs)      // options
            i += 4
            set_oam_x(i, px+8)     // x-position
            set_oam_y(i, py) // y-position
            set_oam_p(i, pwhich_sprite)    // tile
            set_oam_a(i, pattrs)      // options
            i += 4

    // Clear the remainder of OAM
    hide_oam(i)

// this function calculates the movements of the player character
fn move_player()

    //check if we are on a platform
    is_player_on_platform=false
    for U i=0; i<level_num_platforms; i+=1
        UU platformx=f_platforms[i].map_x
        UU platformy=f_platforms[i].map_y
        if ( ((player_map_x+player_char_width) >= platformx) && (player_map_x <= (platformx+platform_width)) && ((player_y+player_char_height+1)==platformy) )
            is_player_on_platform=true
            is_player_jumping=false
            is_player_on_ground=true
            //goto mode play_level1()  // Initialize game by entering the play level mode
            //: preserves
            if ((f_platforms[i].x_speed) > 0)
                button_right_pressed() // move with the platform
            else
                button_left_pressed() // move with the platform


    // adjust sprite to simulate walking
    if (is_player_on_ground && (!is_player_on_platform))
        which_player_sprite_show=((player_map_x.a>>4)&1)
    else
        which_player_sprite_show=0

    // check if the player has a ground underneath
    if (is_ground_close(1) || is_player_on_platform)
        is_player_jumping=false
        is_player_on_ground=true

    // check if the player is on the air
    if (is_player_on_the_air() && (!is_player_on_platform))
        is_player_on_ground=false

    if (did_touch_wall_up())
        is_player_jumping=false

    // Check if the player can move left. It also manages horizontal scroll window
    if pads[0].held & BUTTON_LEFT
        button_left_pressed()
            
    // Check if the player can move right. It also manages horizontal scroll window
    if pads[0].held & BUTTON_RIGHT
        button_right_pressed()

    // check if player pressed jump button
    if ( (pads[0].pressed & BUTTON_A) && is_player_on_ground && (!did_touch_wall_up()) ) 
        count_frames_jumping=0
        is_player_jumping=true
        is_player_on_ground=false

    // simulate gravity (player falling slowly)
    if ( (!is_player_on_ground) && (!is_player_jumping) )
        if (is_ground_close(falling_rate_px))
            player_y+=1
        else
            player_y+=falling_rate_px
    //

    // simulate jump
    if (is_player_jumping)
        player_y-=jump_values[count_frames_jumping]
        count_frames_jumping+=1
    
    // check if jumping should stop
    if (count_frames_jumping >= num_jump_values)
        is_player_jumping=false

    // adjust player sprite if looking left
    if (is_player_looking_left)
        which_player_sprite_show+=2

    // check if player fell into an abism
    if (player_y>=240)
        goto mode play_level2()  // Initialize game by entering the play level mode
        : preserves


// move the enemies through the level
fn move_enemies()
    // move enemies
    for U i=0; i<level_num_snake_enemies; i+=1
        if (snake_enemies[i].status == 0)
            snake_enemies[i].map_x+=snake_enemies[i].x_speed
            //
            if (snake_enemies[i].map_x <= snake_enemies[i].initial_x)
                snake_enemies[i].x_speed=1
            if (snake_enemies[i].map_x >= snake_enemies[i].final_x)
                snake_enemies[i].x_speed=-1

    // check if player crushed an enemy, killing it
    for U i=0; i<level_num_snake_enemies; i+=1
        if (did_crush_enemy(i))
                snake_enemies[i].status=1

    // check if an enemy killed the player
    for U i=0; i<level_num_snake_enemies; i+=1
        if (snake_enemies[i].status == 0)
            if ( intersect(player_map_x, player_y, player_map_x+player_char_width, player_y+player_char_height, 
                snake_enemies[i].map_x, snake_enemies[i].map_y, snake_enemies[i].map_x+enemy_char_width, snake_enemies[i].map_y+enemy_char_height) )
                goto mode play_level1()  // Initialize game by entering the play level mode
                : preserves

    // check if a dead enemy has to fall until it dissapears
    for U i=0; i<level_num_snake_enemies; i+=1
        if (snake_enemies[i].status == 1)
            snake_enemies[i].map_y+=1
            if (snake_enemies[i].map_y >= 240)
                snake_enemies[i].status=2 // dead and no more movements

// move the platforms
fn move_platforms()
    for U i=0; i<level_num_platforms; i+=1
        f_platforms[i].map_x+=f_platforms[i].x_speed
        if (f_platforms[i].map_x <= f_platforms[i].initial_x)
            f_platforms[i].x_speed=1
        if (f_platforms[i].map_x >= f_platforms[i].final_x)
            f_platforms[i].x_speed=-1

/* This function sets a 9 bit scroll
    instead of the 8 bit ppu_reset_scroll
    from nes.fab library: https://www.nesdev.org/wiki/PPU_scrolling
    */
fn ppu_reset_scroll_16(UU x, UU y)
    ppu_reset_scroll(x.a, y.a) // the 9th bits should go to ppuctrl right after
    {PPUCTRL}(PPUCTRL_NMI_ON | (x.b & 1) | ((y.b & 1)<<1))  // Set PPU control register, we want NMIs

/*
This function calculates the BG piece to put into the namespace 
after right scrolling, and its attributes (palettes). 
*/
fn calc_right_scr_bg(UU x)
    UU x_right=x+255
    UU column=(x_right.a >> 3)
    UU col_start_addr
    UU attr_base_addr
    // calculate the correct namespace 
    if (x_right.b & 1)
        col_start_addr=$2400+column
        attr_base_addr=$2400+960
        
    else
        col_start_addr=$2000+column
        attr_base_addr=$2000+960
    // calculate the 8x8 tiles that will patch the screen
    UU mt_map_col_start=(x_right >> 4)
    U y=0
    UU map_mt_pointer=(mt_map_col_start << 4)
    for U i=0; i<15; i+=1
        U metatile=lvl1_mt_map{map_mt_pointer}
        //select whether it's the left or right column of the 2x2 metatile
        if (column & 1)
            scroll_tiles[y]=mt_ne[metatile]
            scroll_tiles[y+1]=mt_se[metatile]
        else
            scroll_tiles[y]=mt_nw[metatile]
            scroll_tiles[y+1]=mt_sw[metatile]
        y+=2
        map_mt_pointer+=1
    // calculate the addresses where data will be written
    scr_bg_update_base_addr=col_start_addr
    scr_attr_bg_update_base_addr=attr_base_addr
    scr_attr_bg_update_base_addr+=(x_right.a >> 5)
    // calculate the attributes data
    UU base_mt_attr=(x_right >> 4)
    base_mt_attr&=$fffe
    base_mt_attr=(base_mt_attr<<4)
    U iii=0
    for UU i=0; i<15; i+=2
        U my_metatile=lvl1_mt_map{base_mt_attr+i} //tl
        U my_attr=mt_attr{my_metatile}
        my_metatile=lvl1_mt_map{base_mt_attr+i+16} // tr
        my_attr|=(mt_attr{my_metatile}<<2)
        my_metatile=lvl1_mt_map{base_mt_attr+i+1} //bl
        my_attr|=(mt_attr{my_metatile}<<4)
        my_metatile=lvl1_mt_map{base_mt_attr+i+17} //br
        my_attr|=(mt_attr{my_metatile}<<6)
        scroll_attrs[iii]=my_attr
        iii+=1
    //
    scr_bg_update_needed=true

/*
Copies to the adequate namespace addr the bg piece needed
This function is to be called when NMI takes place.
*/
fn nmi_update_screen_bg()
    {PPUSTATUS}() // Reset the address latch just to be safe.
    {PPUCTRL}(PPUCTRL_VRAM_32_DOWN) // Used to write columns of data. Addr incs in 32 every write.
    // write the column to the namespace
    ppu_reset_addr(scr_bg_update_base_addr)
    for U y=0; y<30; y+=1
        {PPUDATA}(scroll_tiles[y])
    // now write the attrs. remember we are in addr+32 mode every write
    U i=0
    for UU attri=0; attri<32; attri+=8
        ppu_reset_addr(scr_attr_bg_update_base_addr+attri)
        {PPUDATA}(scroll_attrs[i])
        {PPUDATA}(scroll_attrs[i+4])
        i+=1
    //
    scr_bg_update_needed=false


fn calc_left_scr_bg(UU x)
    UU column=(x.a >> 3)
    UU col_start_addr
    UU attr_base_addr
    // calculate the correct namespace 
    if (x.b & 1)
        col_start_addr=$2400+column
        attr_base_addr=$2400+960
        
    else
        col_start_addr=$2000+column
        attr_base_addr=$2000+960
    // calculate the 8x8 tiles that will patch the screen
    UU mt_map_col_start=(x >> 4)
    U y=0
    UU map_mt_pointer=(mt_map_col_start << 4)
    for U i=0; i<15; i+=1
        U metatile=lvl1_mt_map{map_mt_pointer}
        //select whether it's the left or right column of the 2x2 metatile
        if (column & 1)
            scroll_tiles[y]=mt_ne[metatile]
            scroll_tiles[y+1]=mt_se[metatile]
        else
            scroll_tiles[y]=mt_nw[metatile]
            scroll_tiles[y+1]=mt_sw[metatile]
        y+=2
        map_mt_pointer+=1
    // calculate the addresses where data will be written
    scr_bg_update_base_addr=col_start_addr
    scr_attr_bg_update_base_addr=attr_base_addr
    scr_attr_bg_update_base_addr+=(x.a >> 5)
    // calculate the attributes data
    UU base_mt_attr=(x >> 4)
    base_mt_attr&=$fffe
    base_mt_attr=(base_mt_attr<<4)
    U iii=0
    for UU i=0; i<15; i+=2
        U my_metatile=lvl1_mt_map{base_mt_attr+i} //tl
        U my_attr=mt_attr{my_metatile}
        my_metatile=lvl1_mt_map{base_mt_attr+i+16} // tr
        my_attr|=(mt_attr{my_metatile}<<2)
        my_metatile=lvl1_mt_map{base_mt_attr+i+1} //bl
        my_attr|=(mt_attr{my_metatile}<<4)
        my_metatile=lvl1_mt_map{base_mt_attr+i+17} //br
        my_attr|=(mt_attr{my_metatile}<<6)
        scroll_attrs[iii]=my_attr
        iii+=1
    //
    scr_bg_update_needed=true

// returns the map metatile at screen pixel position (x, y)
fn get_mt_at_pix(UU x, UU y) U
    UU disp= ((x >> 4) << 4) + (y >> 4)
    U mt=lvl1_mt_map{disp}
    return mt

// returns if the player is  touching a wall to its right
// it only works right with player_x_move_inc=1
fn did_touch_wall_right () Bool
    if ( (get_mt_at_pix(player_map_x+player_char_width, player_y+1) >= pass_through_mt) || 
        (get_mt_at_pix(player_map_x+player_char_width, player_y+player_char_height-1) >= pass_through_mt) )
        return true
    return false

// returns if the player is touching a wall to its left
// it only works right with player_x_move_inc=1
fn did_touch_wall_left () Bool
    if ( (get_mt_at_pix(player_map_x-1, player_y+1) >= pass_through_mt) || 
        (get_mt_at_pix(player_map_x-1, player_y+player_char_height-1) >= pass_through_mt) )
        return true
    return false

// returns if the player is touching a wall with its head
// it only works with num_jump_increment=1
fn did_touch_wall_up () Bool
    if ( (get_mt_at_pix(player_map_x, player_y) >= pass_through_mt) || 
        (get_mt_at_pix(player_map_x+player_char_width-1, player_y) >= pass_through_mt) )
        return true
    return false

// returns if we touch the gound in the next pxdown pixels
fn is_ground_close (UU pxdown) Bool
    if ( (get_mt_at_pix(player_map_x, player_y+player_char_height+pxdown) >= pass_through_mt) || 
        (get_mt_at_pix(player_map_x+player_char_width-1, player_y+player_char_height+pxdown) >= pass_through_mt) )
        return true
    return false

// returns whether the player is on the air
fn is_player_on_the_air() Bool
    if ( (get_mt_at_pix(player_map_x, player_y+player_char_height+1) < pass_through_mt) && 
        (get_mt_at_pix(player_map_x+player_char_width-1, player_y+player_char_height+1) < pass_through_mt) )
        return true
    return false

// returns if 2 rectangles intersect
fn intersect (UU r1x1, UU r1y1, UU r1x2, UU r1y2, UU r2x1, UU r2y1, UU r2x2, UU r2y2) Bool
    if ( (r1x1 >= r2x1) && (r1x1 <= r2x2) ||
        (r1x2 >= r2x1) && ( r1x2 <= r2x2) )
        if ( (r1y1 >= r2y1) && (r1y1 <= r2y2) ||
            (r1y2 >= r2y1) && ( r1y2 <= r2y2) )
            return true
    return false

// returns if the player crushed an enemy
fn did_crush_enemy(U i) Bool
    if ( ((player_map_x > snake_enemies[i].map_x) && (player_map_x < (snake_enemies[i].map_x+enemy_char_width))) ||
        (((player_map_x+player_char_width) > snake_enemies[i].map_x) && ((player_map_x+player_char_width) < (snake_enemies[i].map_x+enemy_char_width))) )
        if (((player_y+player_char_height+1) == snake_enemies[i].map_y) && (!is_player_on_ground))
            return true
    return false

fn button_left_pressed()
    is_player_looking_left=true
    if (!did_touch_wall_left())
        //
        if (player_window_x > x_window_min)
            player_window_x-=player_x_move_inc
        else
            if (my_x_scroll >= player_x_move_inc)
                my_x_scroll-=player_x_move_inc
            else
                my_x_scroll=0
                if (player_window_x >= player_x_move_inc)
                    player_window_x-=player_x_move_inc
                else
                    player_window_x=0
        //
        calc_left_scr_bg(my_x_scroll)
        //
        player_map_x=my_x_scroll // calculate player x coord in map
        player_map_x+=player_window_x

fn button_right_pressed()
    is_player_looking_left=false
    if (!did_touch_wall_right())
        //
        if ((player_window_x+player_char_width) < x_window_max)
            player_window_x+=player_x_move_inc
        else
            if ((my_x_scroll+player_x_move_inc) <= maximum_x)
                my_x_scroll+=player_x_move_inc
            else
                my_x_scroll=maximum_x
                if ((player_window_x+player_x_move_inc+player_char_width) <= 255)
                    player_window_x+=player_x_move_inc
                else
                    player_window_x=256-player_char_width
        //
        calc_right_scr_bg(my_x_scroll)
        //
        player_map_x=my_x_scroll // calculate player x coord in map
        player_map_x+=player_window_x
