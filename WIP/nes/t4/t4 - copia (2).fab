
mapfab(raw, "t4.mapfab", "chr", "palette", "metatiles", "level")

vars /game_vars
    CCC/levels lvl1_mt_map

    UU my_x_scroll=0
    UU scr_bg_update_base_addr
    Bool scr_bg_update_needed=false

/*
Writes the initial 32x30 screen. Take note the mapfab is (16*4)H x 16V
*/
fn load_screen(CCC/levels my_lvl_pointer)
    U chr_bank = read U(my_lvl_pointer)
    CCC/palettes pal=read CCC/palettes(my_lvl_pointer)
    CC/metatiles mymetatiles=read CC/metatiles(my_lvl_pointer)
    UU size = UU(read U(my_lvl_pointer)) // width in metatiles of screen
    //after all these reads, now my_lvl_pointer points to the metatiles matrix

    // set palette
    load_palette(pal)
    ppu_upload_palette()
       
    UU mt_size = UU(read U(mymetatiles)) // number of metatiles
    if mt_size == 0
        mt_size = 256

    lvl1_mt_map=my_lvl_pointer // the map is set in columns. it's in level.macrofab
    
    CC/metatiles mt_nw=mymetatiles
    CC/metatiles mt_ne=mt_nw
    mt_ne+=mt_size
    CC/metatiles mt_sw=mt_ne
    mt_sw+=mt_size
    CC/metatiles mt_se=mt_sw
    mt_se+=mt_size
    CC/metatiles mt_attr=mt_se
    mt_attr+=mt_size
    // now every pointer points where it should

    ppu_reset_addr($2000) // first screen // https://www.nesdev.org/wiki/Mirroring

    {PPUSTATUS}() // Reset the address latch before 'ppu_set_addr', just to be safe.
    {PPUCTRL}(PPUCTRL_VRAM_32_DOWN) // Used to write columns of data.

    // upload first namespace data
    UU i=0
    UU ii=0

    for UU x=0; x<16; x+=1
        ppu_reset_addr($2000+ii)
        for UU y=0; y<16; y+=1
            U my_metatile=my_lvl_pointer{i}
            U nw_tile=mt_nw{my_metatile}
            U sw_tile=mt_sw{my_metatile}
            {PPUDATA}(nw_tile)
            {PPUDATA}(sw_tile)
            i+=1
        i-=16
        ii+=1
        ppu_reset_addr($2000+ii)
        for UU y=0; y<16; y+=1
            U my_metatile=my_lvl_pointer{i}
            U ne_tile=mt_ne{my_metatile}
            U se_tile=mt_se{my_metatile}
            {PPUDATA}(ne_tile)
            {PPUDATA}(se_tile)
            i+=1
        ii+=1

    //upload first attributes data, we need to OR it together
    //for every 2x2 metatiles block (https://www.nesdev.org/wiki/PPU_attribute_tables)
    i=0
    ii=0
    for UU a=0; a<8; a+=1
        for UU attri=0; attri<32; attri+=8
            ppu_reset_addr($2000+960+a+attri)
            U my_metatile=my_lvl_pointer{i} //tl
            U my_attr=mt_attr{my_metatile}
            //
            my_metatile=my_lvl_pointer{i+15} // tr
            my_attr|=(mt_attr{my_metatile}<<2)
            //
            my_metatile=my_lvl_pointer{i+1} //bl
            my_attr|=(mt_attr{my_metatile}<<4)
            //
            my_metatile=my_lvl_pointer{i+16} //br
            my_attr|=(mt_attr{my_metatile}<<6)
            //
            {PPUDATA}(my_attr)
            //
            my_metatile=my_lvl_pointer{i+8} //tl
            my_attr=mt_attr{my_metatile}
            //
            my_metatile=my_lvl_pointer{i+15+8} // tr
            my_attr|=(mt_attr{my_metatile}<<2)
            //
            my_metatile=my_lvl_pointer{i+1+8} //bl
            my_attr|=(mt_attr{my_metatile}<<4)
            //
            my_metatile=my_lvl_pointer{i+16+8} //br
            my_attr|=(mt_attr{my_metatile}<<6)
            //
            {PPUDATA}(my_attr)
            i+=2
        ii+=30
        i=ii


nmi main_nmi()
    // Update OAM and poll the pads:
    ppu_upload_oam_poll_pads(0)

    // Turn on rendering:
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    // Reset the scroll https://www.nesdev.org/wiki/PPU_scrolling
    // and https://www.nesdev.org/wiki/Mirroring
    if scr_bg_update_needed
        nmi_update_screen_bg()
    //
    ppu_reset_scroll_16(my_x_scroll, 0)
    
mode main()
: nmi main_nmi

    load_screen(@lev_level1) // the name lev_level1 is defined in the levels.macrofab
    // Tell the NES to trigger NMI once per frame:
    {PPUCTRL}(PPUCTRL_NMI_ON)

    // Wait forever, one frame at a time:
    while true
        update_pads()
        move_player() 
        update_sprites()
        nmi // Wait for the next NMI

fn update_sprites()
    // Our stack index into OAM:
    U i = 0
    // Push sprites
    set_oam_x(i, 0)     // x-position
    set_oam_y(i, 0) // y-position
    set_oam_p(i, 8)    // empty tile
    set_oam_a(i, 0)      // options
    i += 4

    // Clear the remainder of OAM
    hide_oam(i)

fn move_player()
    /*
    the X scroll runs smoothly but the Y scroll doesn't quite
    work the way you'd expect. The 9th bit selects the namespace (screen)
    and the 8 bit left (up to 239) the scroll inside that screen.
    More info in https://www.nesdev.org/wiki/PPU_scrolling
    */
    if pads[0].held & BUTTON_LEFT
        my_x_scroll-=1
    if pads[0].held & BUTTON_RIGHT
        my_x_scroll+=1
        calc_right_scr_bg(my_x_scroll)


/* This function sets a 9 bit scroll
    instead of the 8 bit ppu_reset_scroll
    from nes.fab library: https://www.nesdev.org/wiki/PPU_scrolling
    */
fn ppu_reset_scroll_16(UU x, UU y)
    ppu_reset_scroll(x.a, y.a) // the 9th bits should go to ppuctrl right after
    {PPUCTRL}(PPUCTRL_NMI_ON | (x.b & 1) | ((y.b & 1)<<1))  // Set PPU control register, we want NMIs

/*
This function calculates the BG piece to put into the namespace 
after right scrolling. 
*/
fn calc_right_scr_bg(UU x)
    UU x_right=x+256
    UU column=(x_right.a>>4)
    UU col_start_addr
    //
    if (x_right.b & 1)
        col_start_addr=$2400+(column<<1)
        
    else
        col_start_addr=$2000+(column<<1)
    //
    scr_bg_update_base_addr=col_start_addr
    scr_bg_update_needed=true

/*
Copies to the adequate namespace addr the bg piece needed
This function is to be called when NMI takes place.
*/
fn nmi_update_screen_bg()
    {PPUSTATUS}() // Reset the address latch just to be safe.
    {PPUCTRL}(PPUCTRL_VRAM_32_DOWN) // Used to write columns of data. Addr incs in 32 every write.
    //
    ppu_reset_addr(scr_bg_update_base_addr)
    for UU y=0; y<30; y+=1
        {PPUDATA}(5)
    //
    ppu_reset_addr(scr_bg_update_base_addr+1)
    for UU y=0; y<30; y+=1
        {PPUDATA}(6)


