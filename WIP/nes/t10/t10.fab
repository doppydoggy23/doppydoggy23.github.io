
mapfab(raw, "t10.mapfab", "chr", "palette", "metatiles", "level")
//mapfab(raw, "modproj1.mapfab", "chr", "palette", "metatiles", "level")

ct U BALL_SPRITE=0

struct BallInfo
    U xpos
    U ypos
    S xinc
    S yinc

vars /game_vars
    BallInfo ball

    U[16*15] level_mt_map // level 1 map of metatiles in RAM

    //pointer to the arrays of the 2x2 tiles (and attr) that make every metatile
    CC/metatiles mt_nw
    CC/metatiles mt_ne
    CC/metatiles mt_sw
    CC/metatiles mt_se
    CC/metatiles mt_attr

    // we temporary need to store the collision 
    // to update the map/GFX mem during VBLANK
    Bool is_collision_pending=false
    U collision_col
    U collision_row
    U updated_metatile

/*
Loads a 16x15 metatiles screen made with MapFab. 
Its only argument is a pointer to the levels struct 
made with the macros included in the earlier mapfab()
*/
fn load_screen(CCC/levels my_lvl_pointer)
    U chr_bank = read U(my_lvl_pointer)
    CCC/palettes pal=read CCC/palettes(my_lvl_pointer)
    CC/metatiles mymetatiles=read CC/metatiles(my_lvl_pointer)
    UU size = UU(read U(my_lvl_pointer)) // width in metatiles of screen
    //after all these reads, now my_lvl_pointer points to the metatiles matrix

    // set palette
    load_palette(pal)
    ppu_upload_palette()
       
    UU mt_size = UU(read U(mymetatiles)) // number of metatiles
    if mt_size == 0
        mt_size = 256
    //after this read now mymetatiles points to the 
    // metatiles struct made with the metatiles.macrofab in the mapfab ()
    
    mt_nw=mymetatiles
    mt_ne=mt_nw
    mt_ne+=mt_size
    mt_sw=mt_ne
    mt_sw+=mt_size
    mt_se=mt_sw
    mt_se+=mt_size
    mt_attr=mt_se
    mt_attr+=mt_size
    // now every pointer points where it should

    U i=0
    ppu_reset_addr($2000)
    
    // upload namespace data
    for U y=0; y<15; y+=1
        for U x=0; x<16; x+=1
            U my_metatile=my_lvl_pointer{i}
            U nw_tile=mt_nw{my_metatile}
            U ne_tile=mt_ne{my_metatile}
            {PPUDATA}(nw_tile)
            {PPUDATA}(ne_tile)
            i+=1
        i=i-16
        for U x=0; x<16; x+=1
            U my_metatile=my_lvl_pointer{i}
            U sw_tile=mt_sw{my_metatile}
            U se_tile=mt_se{my_metatile}
            {PPUDATA}(sw_tile)
            {PPUDATA}(se_tile)
            i+=1

    //upload attributes data, we need to OR it together
    //for every 2x2 metatiles block (https://www.nesdev.org/wiki/PPU_attribute_tables)
    i=0
    for U y=0; y<15; y+=2
        for U x=0; x<16; x+=2
            U my_metatile=my_lvl_pointer{i}
            U my_attr=mt_attr{my_metatile}
            //
            my_metatile=my_lvl_pointer{i+1}
            my_attr|=(mt_attr{my_metatile}<<2)
            //
            my_metatile=my_lvl_pointer{i+16}
            my_attr|=(mt_attr{my_metatile}<<4)
            //
            my_metatile=my_lvl_pointer{i+17}
            my_attr|=(mt_attr{my_metatile}<<6)
            i+=2
            {PPUDATA}(my_attr)
        i+=16
            
    // copy the level metatiles map to RAM
    for U iv=0; iv<(16*15); iv+=1
        level_mt_map{iv}=my_lvl_pointer{iv}


nmi main_nmi()
    // we need to update GFXs while NMI, so we do this now
    if is_collision_pending
        set_metatile_at_colrow(collision_col, collision_row, updated_metatile)
        is_collision_pending=false

    // Update OAM and poll the pads:
    ppu_upload_oam_poll_pads(0)

    // Turn on rendering:
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    // Reset the scroll
    ppu_reset_scroll(0, 0)
    
mode main()
: nmi main_nmi

    load_screen(@lev_level1) // the name lev_level1 is defined in the levels.macrofab
    // Tell the NES to trigger NMI once per frame:
    {PPUCTRL}(PPUCTRL_NMI_ON)

    // initialize vars
    ball.xinc=1
    ball.yinc=-1
    ball.xpos=200
    ball.ypos=200

    // Wait forever, one frame at a time:
    while true
        update_pads()
        move_player() 
        update_sprites()
        nmi // Wait for the next NMI

fn move_player ()
    if pads[0].held & BUTTON_LEFT
        ball.xpos -= 1
    if pads[0].held & BUTTON_RIGHT
        ball.xpos += 1
    if pads[0].held & BUTTON_UP
        ball.ypos -= 1
    if pads[0].held & BUTTON_DOWN
        ball.ypos += 1

fn update_sprites()
    // Our stack index into OAM:
    U i = 0

    // update balls position
/*DEBUG    ball.xpos+=ball.xinc
    ball.ypos+=ball.yinc
*/
    // check collisions
    if get_metatile_at_pix(ball.xpos, ball.ypos) > 0
        collision_col=(ball.xpos>>4)
        collision_row=(ball.ypos>>4)
        manage_collision (collision_col, collision_row)
    if get_metatile_at_pix((ball.xpos+8), ball.ypos) > 0
        collision_col=((ball.xpos+8)>>4)
        collision_row=(ball.ypos>>4)
        manage_collision (collision_col, collision_row)
    if get_metatile_at_pix(ball.xpos, (ball.ypos+8)) > 0
        collision_col=(ball.xpos>>4)
        collision_row=((ball.ypos+8)>>4)
        manage_collision (collision_col, collision_row)
    if get_metatile_at_pix((ball.xpos+8), (ball.ypos+8)) > 0
        collision_col=((ball.xpos+8)>>4)
        collision_row=((ball.ypos+8)>>4)
        manage_collision (collision_col, collision_row)

    // Push sprites
    set_oam_x(i, ball.xpos)     // x-position
    set_oam_y(i, ball.ypos) // y-position
    set_oam_p(i, BALL_SPRITE)    // tile
    set_oam_a(i, 0)      // options
    i += 4

    // Clear the remainder of OAM
    hide_oam(i)

/*
returns the map metatile at screen pixel position (px, py)
*/
fn get_metatile_at_pix (U px, U py) U
    UU lvlmtm=(((py>>4)<<4)+(px>>4))
    U t=level_mt_map{lvlmtm}
    return t
/*

returns the map metatile at screen column/row
*/
fn get_metatile_at_col_row (U col, U row) U
    return level_mt_map{(row<<4)+col}

/*
Sets the row,col metatile to a new value.
This is done in the collisions_map variable because
it's likely lvl1_mtmap_ptr points to ROM 
Notice that x,y are UU values, if defined as U, 
the math here for bit shifting wouldn't work
*/
fn set_metatile_at_colrow (UU x, UU y, U new_mt)
    // write to the ram metatiles map
    UU map_displacement=((y<<4)+x)
    level_mt_map{map_displacement}=new_mt

    // change that metatile position in GFX RAM
    // first the tiles
    UU gfx_addr=((y<<6)+(x<<1))
    gfx_addr+=$2000
    ppu_reset_addr(gfx_addr)    
    {PPUDATA}( mt_nw{new_mt} )
    {PPUDATA}( mt_ne{new_mt} )
    gfx_addr+=32
    ppu_reset_addr(gfx_addr)    
    {PPUDATA}( mt_sw{new_mt} )
    {PPUDATA}( mt_se{new_mt} )

    //calculate the new 2x2 metatiles block attributes byte
    UU mt_m_disp=(((y & %11111110) <<4)+(x & %11111110))
    U mt_2x2_pos=U(((y&1)<<1)|(x & 1))
    //
    U my_metatile=level_mt_map{mt_m_disp}
    U new_attr=mt_attr{my_metatile}
    //
    my_metatile=level_mt_map{mt_m_disp+1}
    new_attr|=(mt_attr{my_metatile}<<2)
    //
    my_metatile=level_mt_map{mt_m_disp+16}
    new_attr|=(mt_attr{my_metatile}<<4)
    //
    my_metatile=level_mt_map{mt_m_disp+17}
    new_attr|=(mt_attr{my_metatile}<<6)
    //

    //now access the attributes(palettes) address
    UU attr_addr_disp=(((y>>1)<<3)+(x>>1))
    ppu_reset_addr($2000+960+attr_addr_disp)
    {PPUDATA}(new_attr)

// manages collision with a metatile at col/row
fn manage_collision (U col_col, U col_row)
    U colli_metatile=get_metatile_at_col_row(col_col, col_row)
    //
    if (colli_metatile==11) // two 8-wide horizontal blocks
        collision_col=col_col
        collision_row=col_row
        updated_metatile=1 // garbage BG
        is_collision_pending=true
        U coll_x=col_col<<4
        U coll_y=col_row<<4
/*DEBUG        if (overlap(make_rect(coll_x+1,coll_y+1, 15, 2),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //upper brick, upper side
            updated_metatile=10 // convert it to: only lower brick
            ball.yinc=-1 // bounce up
            return
*/
/* WHY ONLY THIS WORKS        if (ball.xpos>=coll_x)&&(ball.xpos<=(coll_x+15)) || ((ball.xpos+8)>=coll_x)&&((ball.xpos+8)<=(coll_x+15))
            if ((ball.ypos<coll_y)&&((ball.ypos+8)<=coll_y+2))
                updated_metatile=10 // convert it to: only lower brick
                ball.yinc=-1 // bounce up
                return
*/        //




 /* DEBUG       if (overlap(make_rect(coll_x+1,coll_y+1+8+6, 15, 2),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //lower brick, lower side
            updated_metatile=9 // convert it to: only upper brick
            ball.yinc=+1 // bounce down
            return
        //
        if (overlap(make_rect(coll_x+1,coll_y+1, 2, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //upper brick, left side
            updated_metatile=10 // convert it to: only lower brick
            ball.xinc=-1 // bounce left
            return
        //
        if (overlap(make_rect(coll_x+1+13,coll_y+1, 2, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //upper brick, right side
            updated_metatile=10 // convert it to: only lower brick
            ball.xinc=1 // bounce right
            return
        //
        if (overlap(make_rect(coll_x+1,coll_y+1+8, 2, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //lower brick, left side
            updated_metatile=9 // convert it to: only upper brick
            ball.xinc=-1 // bounce left
            return
        //
        if (overlap(make_rect(coll_x+1+13,coll_y+1+8, 2, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //lower brick, right side
            updated_metatile=9 // convert it to: only upper brick
            ball.xinc=1 // bounce right
            return
        //
*/
        if ( rect_overlap(coll_x+1,coll_y+3, coll_x+15, coll_y+1, ball.xpos, ball.ypos+8, ball.xpos+8, ball.ypos) ) //upper brick, upper side
            updated_metatile=10 // convert it to: only lower brick
            ball.yinc=-1 // bounce up
            return

        return
    //
    if (col_col==0)
        ball.xinc=1
    if (col_col==15)
        ball.xinc=-1
    if (col_row==0)
        ball.yinc=1
    if (col_row==14)
        ball.yinc=-1
    
/*
Rectangle 1 (rec1): defined by its bottom-left corner (x1, y1) and top-right corner (x2, y2). 
Rectangle 2 (rec2): defined by its bottom-left corner (x3, y3) and top-right corner (x4, y4). 
*/
fn rect_overlap (U x1, U y1, U x2, U y2, U x3, U y3, U x4, U y4) Bool
    return !((x4 <= x1) || (x3 >= x2) || (y4 <= y1) || (y3 >= y2))

/*fn rect_overlap (U x1, U y2, U x2, U y1, U x3, U y4, U x4, U y3) Bool
    return !(x4 <= x1 || x3 >= x2 || y4 <= y1 || y3 >= y2)
*/