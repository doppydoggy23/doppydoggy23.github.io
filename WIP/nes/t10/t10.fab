
mapfab(raw, "t10.mapfab", "chr", "palette", "metatiles", "level")
//mapfab(raw, "modproj1.mapfab", "chr", "palette", "metatiles", "level")

ct U BALL_SPRITE=0

struct BallInfo
    U xpos
    U ypos
    S xinc
    S yinc

vars /game_vars
    BallInfo ball

    U[16*15] level_mt_map // level 1 map of metatiles in RAM

    //pointer to the arrays of the 2x2 tiles (and attr) that make every metatile
    CC/metatiles mt_nw
    CC/metatiles mt_ne
    CC/metatiles mt_sw
    CC/metatiles mt_se
    CC/metatiles mt_attr

    // we temporary need to store the collision 
    // to update the map/GFX mem during VBLANK
    Bool is_collision_pending=false
    U collision_col
    U collision_row
    U updated_metatile

/*
Loads a 16x15 metatiles screen made with MapFab. 
Its only argument is a pointer to the levels struct 
made with the macros included in the earlier mapfab()
*/
fn load_screen(CCC/levels my_lvl_pointer)
    U chr_bank = read U(my_lvl_pointer)
    CCC/palettes pal=read CCC/palettes(my_lvl_pointer)
    CC/metatiles mymetatiles=read CC/metatiles(my_lvl_pointer)
    UU size = UU(read U(my_lvl_pointer)) // width in metatiles of screen
    //after all these reads, now my_lvl_pointer points to the metatiles matrix

    // set palette
    load_palette(pal)
    ppu_upload_palette()
       
    UU mt_size = UU(read U(mymetatiles)) // number of metatiles
    if mt_size == 0
        mt_size = 256
    //after this read now mymetatiles points to the 
    // metatiles struct made with the metatiles.macrofab in the mapfab ()
    
    mt_nw=mymetatiles
    mt_ne=mt_nw
    mt_ne+=mt_size
    mt_sw=mt_ne
    mt_sw+=mt_size
    mt_se=mt_sw
    mt_se+=mt_size
    mt_attr=mt_se
    mt_attr+=mt_size
    // now every pointer points where it should

    U i=0
    ppu_reset_addr($2000)
    
    // upload namespace data
    for U y=0; y<15; y+=1
        for U x=0; x<16; x+=1
            U my_metatile=my_lvl_pointer{i}
            U nw_tile=mt_nw{my_metatile}
            U ne_tile=mt_ne{my_metatile}
            {PPUDATA}(nw_tile)
            {PPUDATA}(ne_tile)
            i+=1
        i=i-16
        for U x=0; x<16; x+=1
            U my_metatile=my_lvl_pointer{i}
            U sw_tile=mt_sw{my_metatile}
            U se_tile=mt_se{my_metatile}
            {PPUDATA}(sw_tile)
            {PPUDATA}(se_tile)
            i+=1

    //upload attributes data, we need to OR it together
    //for every 2x2 metatiles block (https://www.nesdev.org/wiki/PPU_attribute_tables)
    i=0
    for U y=0; y<15; y+=2
        for U x=0; x<16; x+=2
            U my_metatile=my_lvl_pointer{i}
            U my_attr=mt_attr{my_metatile}
            //
            my_metatile=my_lvl_pointer{i+1}
            my_attr|=(mt_attr{my_metatile}<<2)
            //
            my_metatile=my_lvl_pointer{i+16}
            my_attr|=(mt_attr{my_metatile}<<4)
            //
            my_metatile=my_lvl_pointer{i+17}
            my_attr|=(mt_attr{my_metatile}<<6)
            i+=2
            {PPUDATA}(my_attr)
        i+=16
            
    // copy the level metatiles map to RAM
    for U iv=0; iv<(16*15); iv+=1
        level_mt_map{iv}=my_lvl_pointer{iv}


nmi main_nmi()
    // we need to update GFXs while NMI, so we do this now
    if is_collision_pending
        set_metatile_at_colrow(collision_col, collision_row, updated_metatile)
        is_collision_pending=false

    // Update OAM and poll the pads:
    ppu_upload_oam_poll_pads(0)

    // Turn on rendering:
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    // Reset the scroll
    ppu_reset_scroll(0, 0)
    
mode main()
: nmi main_nmi

    load_screen(@lev_level1) // the name lev_level1 is defined in the levels.macrofab
    // Tell the NES to trigger NMI once per frame:
    {PPUCTRL}(PPUCTRL_NMI_ON)

    // initialize vars
    ball.xinc=1
    ball.yinc=-1
    ball.xpos=200
    ball.ypos=200

    // Wait forever, one frame at a time:
    while true
        update_pads()
        move_player() 
        update_sprites()
        nmi // Wait for the next NMI

fn move_player ()
    if pads[0].held & BUTTON_LEFT
        ball.xpos -= 1
    if pads[0].held & BUTTON_RIGHT
        ball.xpos += 1
    if pads[0].held & BUTTON_UP
        ball.ypos -= 1
    if pads[0].held & BUTTON_DOWN
        ball.ypos += 1

fn update_sprites()
    // Our stack index into OAM:
    U i = 0

    // update balls position
    ball.xpos+=ball.xinc
    ball.ypos+=ball.yinc

    // check collisions
    U my_collision_col
    U my_collision_row
/*DEBUG    if get_metatile_at_pix(ball.xpos+4, ball.ypos) > 0 // front
        my_collision_col=((ball.xpos+4)>>4)
        my_collision_row=(ball.ypos>>4)
        manage_collision (my_collision_col, my_collision_row)
    if get_metatile_at_pix((ball.xpos), ball.ypos+4) > 0 //left
        my_collision_col=(ball.xpos>>4)
        my_collision_row=((ball.ypos+4)>>4)
        manage_collision (my_collision_col, my_collision_row)
    if get_metatile_at_pix(ball.xpos+8, (ball.ypos+4)) > 0 // right
        my_collision_col=((ball.xpos+8)>>4)
        my_collision_row=((ball.ypos+4)>>4)
        manage_collision (my_collision_col, my_collision_row)
    if get_metatile_at_pix((ball.xpos+4), (ball.ypos+8)) > 0 // back
        my_collision_col=((ball.xpos+4)>>4)
        my_collision_row=((ball.ypos+8)>>4)
        manage_collision (my_collision_col, my_collision_row)
*/
    if get_metatile_at_pix(ball.xpos, ball.ypos) > 0
        my_collision_col=(ball.xpos>>4)
        my_collision_row=(ball.ypos>>4)
        manage_collision (my_collision_col, my_collision_row)
    if get_metatile_at_pix((ball.xpos+8), ball.ypos) > 0
        my_collision_col=((ball.xpos+8)>>4)
        my_collision_row=(ball.ypos>>4)
        manage_collision (my_collision_col, my_collision_row)
    if get_metatile_at_pix(ball.xpos, (ball.ypos+8)) > 0
        my_collision_col=(ball.xpos>>4)
        my_collision_row=((ball.ypos+8)>>4)
        manage_collision (my_collision_col, my_collision_row)
    if get_metatile_at_pix((ball.xpos+8), (ball.ypos+8)) > 0
        my_collision_col=((ball.xpos+8)>>4)
        my_collision_row=((ball.ypos+8)>>4)
        manage_collision (my_collision_col, my_collision_row)

    // Push sprites
    set_oam_x(i, ball.xpos)     // x-position
    set_oam_y(i, ball.ypos) // y-position
    set_oam_p(i, BALL_SPRITE)    // tile
    set_oam_a(i, 0)      // options
    i += 4

    // Clear the remainder of OAM
    hide_oam(i)

/*
returns the map metatile at screen pixel position (px, py)
*/
fn get_metatile_at_pix (U px, U py) U
    UU lvlmtm=(((py>>4)<<4)+(px>>4))
    U t=level_mt_map{lvlmtm}
    return t
/*

returns the map metatile at screen column/row
*/
fn get_metatile_at_col_row (U col, U row) U
    return level_mt_map{(row<<4)+col}

// sets the new mt at ram map only (not gfx mem)
fn set_mt_at_colrow_map_only (UU x, UU y, U new_mt)
    level_mt_map{((y<<4)+x)}=new_mt

/*
Sets the row,col metatile to a new value.
This is done in the collisions_map variable because
it's likely lvl1_mtmap_ptr points to ROM 
Notice that x,y are UU values, if defined as U, 
the math here for bit shifting wouldn't work
*/
fn set_metatile_at_colrow (UU x, UU y, U new_mt)
    // write to the ram metatiles map
    UU map_displacement=((y<<4)+x)
    level_mt_map{map_displacement}=new_mt

    // change that metatile position in GFX RAM
    // first the tiles
    UU gfx_addr=((y<<6)+(x<<1))
    gfx_addr+=$2000
    ppu_reset_addr(gfx_addr)    
    {PPUDATA}( mt_nw{new_mt} )
    {PPUDATA}( mt_ne{new_mt} )
    gfx_addr+=32
    ppu_reset_addr(gfx_addr)    
    {PPUDATA}( mt_sw{new_mt} )
    {PPUDATA}( mt_se{new_mt} )

    //calculate the new 2x2 metatiles block attributes byte
    UU mt_m_disp=(((y & %11111110) <<4)+(x & %11111110))
    U mt_2x2_pos=U(((y&1)<<1)|(x & 1))
    //
    U my_metatile=level_mt_map{mt_m_disp}
    U new_attr=mt_attr{my_metatile}
    //
    my_metatile=level_mt_map{mt_m_disp+1}
    new_attr|=(mt_attr{my_metatile}<<2)
    //
    my_metatile=level_mt_map{mt_m_disp+16}
    new_attr|=(mt_attr{my_metatile}<<4)
    //
    my_metatile=level_mt_map{mt_m_disp+17}
    new_attr|=(mt_attr{my_metatile}<<6)
    //

    //now access the attributes(palettes) address
    UU attr_addr_disp=(((y>>1)<<3)+(x>>1))
    ppu_reset_addr($2000+960+attr_addr_disp)
    {PPUDATA}(new_attr)

// manages collision with a metatile at col/row
fn manage_collision (U col_col, U col_row)
    U colli_metatile=get_metatile_at_col_row(col_col, col_row)
    //
    if (colli_metatile>=8)&&(colli_metatile<=11) // two 8-wide horizontal blocks metatile
        U coll_x=col_col<<4
        U coll_y=col_row<<4
        U set=(colli_metatile-8)
        //
        if ((set & 1) > 0) // is there an upper block we have to check?
            if (overlap(make_rect(coll_x+1,coll_y+1, 14, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) // is it a hit?
                set &= 2
                if (set==0)
                    updated_metatile=0
                else
                    updated_metatile=set+8
                //ball.xinc=1 // bounce right
                collision_col=col_col
                collision_row=col_row
                is_collision_pending=true
                old_calculate_ball_bounce_b1 (coll_x+1,coll_y+1)
        //
        if ((set & 2) > 0) // is there a lower block we have to check?
            if (overlap(make_rect(coll_x+1,coll_y+1+8, 14, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) // is it a hit?
                set &= 1
                if (set==0)
                    updated_metatile=0
                else
                    updated_metatile=set+8
                //ball.xinc=1 // bounce right
                collision_col=col_col
                collision_row=col_row
                is_collision_pending=true
                old_calculate_ball_bounce_b1 (coll_x+1,coll_y+1+8)
        //
        return
    //
    if (colli_metatile>=12)&&(colli_metatile<=27) // two 8-wide horizontal blocks metatile
        U coll_x=col_col<<4
        U coll_y=col_row<<4
        U set=(colli_metatile-12)
        //
        if ((set & 1) > 0) // is there an upper block we have to check?
            if (overlap(make_rect(coll_x+1,coll_y+1, 6, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) // is it a hit?
                set &= %1111110
                if (set==0)
                    updated_metatile=0
                else
                    updated_metatile=set+12
                collision_col=col_col
                collision_row=col_row
                is_collision_pending=true
                old_calculate_ball_bounce_b2 (coll_x+1,coll_y+1)
        //
        if ((set & 2) > 0) // is there a lower block we have to check?
            if (overlap(make_rect(coll_x+1+8,coll_y+1, 6, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) // is it a hit?
                set &= %11111101
                if (set==0)
                    updated_metatile=0
                else
                    updated_metatile=set+12
                collision_col=col_col
                collision_row=col_row
                is_collision_pending=true
                old_calculate_ball_bounce_b2 (coll_x+1+8,coll_y+1)
        //
        if ((set & 4) > 0) // is there a lower block we have to check?
            if (overlap(make_rect(coll_x+1,coll_y+1+8, 6, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) // is it a hit?
                set &= %11111011
                if (set==0)
                    updated_metatile=0
                else
                    updated_metatile=set+12
                collision_col=col_col
                collision_row=col_row
                is_collision_pending=true
                old_calculate_ball_bounce_b2 (coll_x+1,coll_y+1+8)
        //
        if ((set & 8) > 0) // is there a lower block we have to check?
            if (overlap(make_rect(coll_x+1+8,coll_y+1+8, 6, 6),make_rect(ball.xpos,ball.ypos, 8, 8)) ) // is it a hit?
                set &= %11110111
                if (set==0)
                    updated_metatile=0
                else
                    updated_metatile=set+12
                collision_col=col_col
                collision_row=col_row
                is_collision_pending=true
                old_calculate_ball_bounce_b2 (coll_x+1+8,coll_y+1+8)
        //
        return
    // to reach this point, the caller function must have detected a non-zero mt (collision detected)
    if (col_col==0)
        ball.xinc=1
    if (col_col==15)
        ball.xinc=-1
    if (col_row==0)
        ball.yinc=1
    if (col_row>=14)
        ball.yinc=-1


fn rect_overlap2 (U x1, U y1, U x2, U y2, U x3, U y3, U x4, U y4) Bool
    if ((x1 < x3)&&(x2 < x3))
        return false
    if ((x1 > x4)&&(x2 > x4))
        return false
    if ((y1 < y3)&&(y2 < y3))
        return false
    if ((y1 > y4)&&(y2 > y4))
        return false
    return true

/*
Rectangle 1 (rec1): defined by its bottom-left corner (x1, y1) and top-right corner (x2, y2). 
Rectangle 2 (rec2): defined by its bottom-left corner (x3, y3) and top-right corner (x4, y4). 
*/
/*fn rect_overlap (U x1, U y1, U x2, U y2, U x3, U y3, U x4, U y4) Bool
    return !((x4 <= x1) || (x3 >= x2) || (y4 <= y1) || (y3 >= y2))
*/
fn rect_overlap (U x1, U y2, U x2, U y1, U x3, U y4, U x4, U y3) Bool
    return !(x4 <= x1 || x3 >= x2 || y4 <= y1 || y3 >= y2)

// calculates the boucing of the ball once it hits a rectangular block 1x2
// ToDo: possible compiler bug? why doesn't it work like old_calculate_ball_bounce_b1? DO NOT USE
/*
fn new_calculate_ball_bounce_b1 (U x1, U y1, U width, U height)
    Bool up=false
    Bool down=false
    Bool left=false
    Bool right=false
    // first the sides
    if (overlap(make_rect((x1+1), y1, (width-2), 1),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //upper side
        ball.yinc=-1 // bounce up
        up=true
    if (overlap(make_rect((x1+1), (y1+height), (width-2), 1),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //lower side
        ball.yinc=1 // bounce up
        down=true
    if (overlap(make_rect(x1, (y1+1), 1, (height-2)),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //left side
        ball.xinc=-1 // bounce left
        left=true
    if (overlap(make_rect((x1+width), (y1+1), 1, (height-2)),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //right side
        ball.xinc=1 // bounce right
        right=true
    // now the corners
    if (overlap(make_rect(x1, y1, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!up) && (!left) ) //upper left corner
        ball.xinc=-1 
        ball.yinc=-1 
    if (overlap(make_rect(x1, (y1+height), 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!down) && (!left)) // lower left corner
        ball.xinc=-1 
        ball.yinc=1
    if (overlap(make_rect((x1+width), (y1+height), 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!down) && (!right)) // lower right corner
        ball.yinc=1 
        ball.xinc=1 
    if (overlap(make_rect((x1+width), y1, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!up) && (!right) ) //upper right corner
        ball.xinc=1 
        ball.yinc=-1
*/

// calculates the boucing of the ball once it hits a rectangular block 1x2
fn old_calculate_ball_bounce_b1 (U x1, U y1)
    Bool up=false
    Bool down=false
    Bool left=false
    Bool right=false
    // first the sides
    if (overlap(make_rect(x1+1, y1, 12, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //upper side
        ball.yinc=-1 // bounce up
        up=true
    if (overlap(make_rect(x1+1, y1+6, 12, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //lower side
        ball.yinc=1 // bounce up
        down=true
    if (overlap(make_rect(x1, y1+1, 1, 4),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //left side
        ball.xinc=-1 // bounce left
        left=true
    if (overlap(make_rect(x1+14, y1+1, 1, 4),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //right side
        ball.xinc=1 // bounce right
        right=true
    // now the corners
    if (overlap(make_rect(x1, y1, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!up) && (!left) ) //upper left corner
        ball.xinc=-1 
        ball.yinc=-1 
    if (overlap(make_rect(x1, y1+6, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!down) && (!left)) // lower left corner
        ball.xinc=-1 
        ball.yinc=1
    if (overlap(make_rect(x1+14, y1+6, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!down) && (!right)) // lower right corner
        ball.yinc=1 
        ball.xinc=1 
    if (overlap(make_rect(x1+14, y1, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!up) && (!right) ) //upper right corner
        ball.xinc=1 
        ball.yinc=-1

// calculates the boucing of the ball once it hits a square block 2x2
fn old_calculate_ball_bounce_b2 (U x1, U y1)
    Bool up=false
    Bool down=false
    Bool left=false
    Bool right=false
    // first the sides
    if (overlap(make_rect(x1+1, y1, 4, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //upper side
        ball.yinc=-1 // bounce up
        up=true
    if (overlap(make_rect(x1+1, y1+6, 4, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //lower side
        ball.yinc=1 // bounce up
        down=true
    if (overlap(make_rect(x1, y1+1, 1, 4),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //left side
        ball.xinc=-1 // bounce left
        left=true
    if (overlap(make_rect(x1+6, y1+1, 1, 4),make_rect(ball.xpos,ball.ypos, 8, 8)) ) //right side
        ball.xinc=1 // bounce right
        right=true
    // now the corners
    if (overlap(make_rect(x1, y1, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!up) && (!left) ) //upper left corner
        ball.xinc=-1 
        ball.yinc=-1 
    if (overlap(make_rect(x1, y1+6, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!down) && (!left)) // lower left corner
        ball.xinc=-1 
        ball.yinc=1
    if (overlap(make_rect(x1+6, y1+6, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!down) && (!right)) // lower right corner
        ball.yinc=1 
        ball.xinc=1 
    if (overlap(make_rect(x1+6, y1, 1, 1),make_rect(ball.xpos,ball.ypos, 8, 8)) && (!up) && (!right) ) //upper right corner
        ball.xinc=1 
        ball.yinc=-1
