
mapfab(raw, "t3h.mapfab", "chr", "palette", "metatiles", "level")

vars /game_vars
    CCC/levels lvl1_mt_map


/*
Loads a 2 screen horizontal 32x15 metatiles screen made with MapFab. 
Its only argument is a pointer to the levels struct 
made with the macros included in the earlier mapfab()
*/
fn load_screen(CCC/levels my_lvl_pointer)
    U chr_bank = read U(my_lvl_pointer)
    CCC/palettes pal=read CCC/palettes(my_lvl_pointer)
    CC/metatiles mymetatiles=read CC/metatiles(my_lvl_pointer)
    UU size = UU(read U(my_lvl_pointer)) // width in metatiles of screen
    //after all these reads, now my_lvl_pointer points to the metatiles matrix

    // set palette
    load_palette(pal)
    ppu_upload_palette()
       
    UU mt_size = UU(read U(mymetatiles)) // number of metatiles
    if mt_size == 0
        mt_size = 256

    lvl1_mt_map=my_lvl_pointer
    
    CC/metatiles mt_nw=mymetatiles
    CC/metatiles mt_ne=mt_nw
    mt_ne+=mt_size
    CC/metatiles mt_sw=mt_ne
    mt_sw+=mt_size
    CC/metatiles mt_se=mt_sw
    mt_se+=mt_size
    CC/metatiles mt_attr=mt_se
    mt_attr+=mt_size
    // now every pointer points where it should

    ppu_reset_addr($2000) // first screen // https://www.nesdev.org/wiki/Mirroring
    
    // upload first namespace data
    for UU y=0; y<15; y+=1
        for UU x=0; x<16; x+=1
            U my_metatile=my_lvl_pointer{(y<<5)+x}
            U nw_tile=mt_nw{my_metatile}
            U ne_tile=mt_ne{my_metatile}
            {PPUDATA}(nw_tile)
            {PPUDATA}(ne_tile)
        for UU x=0; x<16; x+=1
            U my_metatile=my_lvl_pointer{(y<<5)+x}
            U sw_tile=mt_sw{my_metatile}
            U se_tile=mt_se{my_metatile}
            {PPUDATA}(sw_tile)
            {PPUDATA}(se_tile)

    //upload first attributes data, we need to OR it together
    //for every 2x2 metatiles block (https://www.nesdev.org/wiki/PPU_attribute_tables)
    for UU y=0; y<15; y+=2
        for UU x=0; x<16; x+=2
            U my_metatile=my_lvl_pointer{(y<<5)+x}
            U my_attr=mt_attr{my_metatile}
            //
            my_metatile=my_lvl_pointer{(y<<5)+x+1}
            my_attr|=(mt_attr{my_metatile}<<2)
            //
            my_metatile=my_lvl_pointer{(y<<5)+x+32}
            my_attr|=(mt_attr{my_metatile}<<4)
            //
            my_metatile=my_lvl_pointer{(y<<5)+x+33}
            my_attr|=(mt_attr{my_metatile}<<6)
            {PPUDATA}(my_attr)            

    ppu_reset_addr($2400) // second screen https://www.nesdev.org/wiki/Mirroring

    // upload second namespace data
    for UU y=0; y<15; y+=1
        for UU x=16; x<32; x+=1
            U my_metatile=my_lvl_pointer{(y<<5)+x}
            U nw_tile=mt_nw{my_metatile}
            U ne_tile=mt_ne{my_metatile}
            {PPUDATA}(nw_tile)
            {PPUDATA}(ne_tile)
        for UU x=16; x<32; x+=1
            U my_metatile=my_lvl_pointer{(y<<5)+x}
            U sw_tile=mt_sw{my_metatile}
            U se_tile=mt_se{my_metatile}
            {PPUDATA}(sw_tile)
            {PPUDATA}(se_tile)

    //upload second attributes data, we need to OR it together
    //for every 2x2 metatiles block (https://www.nesdev.org/wiki/PPU_attribute_tables)
    for UU y=0; y<15; y+=2
        for UU x=16; x<32; x+=2
            U my_metatile=my_lvl_pointer{(y<<5)+x}
            U my_attr=mt_attr{my_metatile}
            //
            my_metatile=my_lvl_pointer{(y<<5)+x+1}
            my_attr|=(mt_attr{my_metatile}<<2)
            //
            my_metatile=my_lvl_pointer{(y<<5)+x+32}
            my_attr|=(mt_attr{my_metatile}<<4)
            //
            my_metatile=my_lvl_pointer{(y<<5)+x+33}
            my_attr|=(mt_attr{my_metatile}<<6)
            {PPUDATA}(my_attr)            

nmi main_nmi()
    // Update OAM and poll the pads:
    ppu_upload_oam_poll_pads(0)

    // Turn on rendering:
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

    // Reset the scroll
    ppu_reset_scroll(0, 0) //https://www.nesdev.org/wiki/PPU_scrolling
    {PPUCTRL}(%00000001) // write the 9th bit
    
mode main()
: nmi main_nmi

    load_screen(@lev_level1) // the name lev_level1 is defined in the levels.macrofab
    // Tell the NES to trigger NMI once per frame:
    {PPUCTRL}(PPUCTRL_NMI_ON)

    // Wait forever, one frame at a time:
    while true
        update_pads()
        //move_player() 
        update_sprites()
        nmi // Wait for the next NMI

fn update_sprites()
    // Our stack index into OAM:
    U i = 0
    // Push sprites
    set_oam_x(i, 0)     // x-position
    set_oam_y(i, 0) // y-position
    set_oam_p(i, 8)    // empty tile
    set_oam_a(i, 0)      // options
    i += 4

    // Clear the remainder of OAM
    hide_oam(i)




